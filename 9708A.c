#pragma config(Sensor, in1,    liftPot,        sensorPotentiometer)
#pragma config(Motor,  port1,           clawLeft,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           moGo,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           armLeft,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           armRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lift,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          clawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2)
#pragma competitionControl(Competition)

#include "Vex_Competition_Includes.c"

#define DEADZONE 20

#define MOTOR_NUM               ((int) kNumbOfTotalMotors)
#define MOTOR_MAX_VALUE         127
#define MOTOR_MIN_VALUE         (-127)
#define MOTOR_DEFAULT_SLEW_RATE 10      // Default will cause 375mS from full fwd to rev
#define MOTOR_FAST_SLEW_RATE    256     // essentially off
#define MOTOR_TASK_DELAY        15      // task 1/frequency in mS (about 66Hz)
#define MOTOR_DEADBAND          10

// Array to hold requested speed for the motors
int motorReq[ MOTOR_NUM ];

// Array to hold "slew rate" for the motors, the maximum change every time the task
// runs checking current mootor speed.
int motorSlew[ MOTOR_NUM ];

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {

	int leftM = 100, rightM = 100, mogoM = 127;

	//Drops the moving goal structure down
	motor[moGo] = - (mogoM);
	wait1Msec(500);
	//Moves forward for 1 seconds
	motor[leftFront] = leftM;
	motor[leftBack] = leftM;
	motor[rightFront] = rightM;
	motor[rightBack] = rightM;
	wait1Msec(2000);
	motor[moGo] = 0;
	wait1Msec(1000);
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	wait1Msec(500);
	//Moves the mobile goal structure upwards
	motor[moGo] = mogoM;
	wait1Msec(2000);
	motor[moGo] = 0;

	//Moves backwards for 1 seconds
	motor[leftFront] = - leftM;
	motor[leftBack] = - leftM;
	motor[rightFront] = - rightM;
	motor[rightBack] = - rightM;
	wait1Msec(3000);
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[rightFront] = 0;
	motor[rightBack] = 0;

	//Turns 180
	motor[leftFront] =  leftM;
	motor[leftBack] = leftM;
	motor[rightFront] = - rightM;
	motor[rightBack] = - rightM;
	wait1Msec(1500);
	motor[leftFront] = leftM;
	motor[leftBack] = leftM;
	motor[rightFront] = rightM;
	motor[rightBack] = rightM;
	wait1Msec(200);
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[rightFront] = 0;
	motor[rightBack] = 0;

	//Puts mobile goal down
	motor[moGo] = - (mogoM);
	wait1Msec(2000);
	motor[moGo] = 0;

	motor[leftFront] = - leftM;
	motor[leftBack] = - leftM;
	motor[rightFront] = - rightM;
	motor[rightBack] = - rightM;
	wait1Msec(1000);
	motor[leftFront] = 0;
	motor[leftBack] = 0;
	motor[rightFront] = 0;
	motor[rightBack] = 0;
	return;
}

task MotorSlewRateTask()
{
    int motorIndex;
    int motorTmp;

    // Initialize stuff
    for(motorIndex=0;motorIndex<MOTOR_NUM;motorIndex++)
        {
        motorReq[motorIndex] = 0;
        motorSlew[motorIndex] = MOTOR_DEFAULT_SLEW_RATE;
        }

    // run task until stopped
    while( true )
        {
        // run loop for every motor
        for( motorIndex=0; motorIndex<MOTOR_NUM; motorIndex++)
            {
            // So we don't keep accessing the internal storage
            motorTmp = motor[ motorIndex ];

            // Do we need to change the motor value ?
            if( motorTmp != motorReq[motorIndex] )
                {
                // increasing motor value
                if( motorReq[motorIndex] > motorTmp )
                    {
                    motorTmp += motorSlew[motorIndex];
                    // limit
                    if( motorTmp > motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // decreasing motor value
                if( motorReq[motorIndex] < motorTmp )
                    {
                    motorTmp -= motorSlew[motorIndex];
                    // limit
                    if( motorTmp < motorReq[motorIndex] )
                        motorTmp = motorReq[motorIndex];
                    }

                // finally set motor
                motor[motorIndex] = motorTmp;
                }
            }

        // Wait approx the speed of motor update over the spi bus
        wait1Msec( MOTOR_TASK_DELAY );
        }
}

int armTarget = 0; //bottom = ,  up = ?
float armkP;
float armkD;
float armError;

task armControl() {
	while(true) {
			armError = armTarget - SensorValue(liftPot);



		wait1Msec(100);
	}


}



task usercontrol() {
	int leftC = 0, rightC = 0, moGoC = 0;
	int leftM = 0, rightM = 0, moGoM = 0;
	int claw = 0;
	int armC = 0;
	int liftC = 0;

	startTask(MotorSlewRateTask);
	while (true) {
		//drive train and mobile goal
		leftC = vexRT[Ch3];
		rightC = vexRT[Ch2];
		moGoC = vexRT[Btn6U] - vexRT[Btn6D];

		if(abs(leftC) > DEADZONE) {
				leftM = leftC;
		} else {
				leftM = 0;
		}

		if(abs(rightC) > DEADZONE) {
				rightM = rightC;
		} else {
				rightM = 0;
		}

		moGoM = 120*(moGoC);

		motorReq[leftFront] = leftM;
		motorReq[leftBack] = leftM;
		motorReq[rightFront] = rightM;
		motorReq[rightBack] = rightM;
		motorReq[moGo] = moGoM;

		int power = 100;

		//claw intake
		claw = vexRT(Btn5UXmtr2)-vexRT(Btn5DXmtr2);
		claw *= power;
		motorReq[clawRight]= claw;
		motorReq[clawLeft]= claw;

		//arm up and down
		int power1 = 120;
		armC = vexRT(Btn8UXmtr2) - vexRT(Btn8DXmtr2);
		armC *= power1;
		motor[armLeft] = armC;
		motor[armRight] = armC;

		//lift up and down
		int power2 = 127;
		liftC = vexRT(Btn6UXmtr2) - vexRT(Btn6DXmtr2);
		if(liftC == 1) {
			liftC = power2/2;
		} else {
		liftC *= power2;
		}
		motorReq[lift] = liftC;




	}
}
